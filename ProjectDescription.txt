Mesh Data Structure,
	- used half edge
	- faces implicitly stored in half_edge* list
		-every three edges defines a face.
	- 

Edge decimation:
- pointers for collapsed edges are modifies.

Quadric simplification

Every vertex has 10 floats that represent the quadric Q matrix. For every edge
in the mesh, an "edge_data" object is created (one for every pair of symmetric
edges) which stores the optimum merge point for the two vertices and the
associated the quadric error. These objects are then stored in a priority queue
sorted by their quadric error. A handle to each of the objects in the in the
priority queue is stored with the associated edge, so that modified edges can
update their "edge_data" object when the error is changed. To go down a level
of detail, the edge at the top of the priority queue is collapsed, and and
degenerate edges are removed from the queue.


Progressive meshes.

Objects are drawn using Vertex Buffer Objects (VBOs). After parsing all of the
vertices from the OFF file, new vertices are appended to the end of the vertex
when created during an edge collapse. This way, once all of the edges are
collapsed, we have calculated and stored all of vertices that are possible at
any level of detail. This makes switching between levels of detail very easy by
simply changing the indices in the element array buffer. This allows us to
simply store the changes in the indices for each level of detail. This is
implemented using a vector of "collapse_data" objects which store the changes
need to move both up and down a level of detail.
